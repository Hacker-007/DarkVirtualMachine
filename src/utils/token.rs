//! The Token struct holds the tokens that are generated by the Lexer.
//! The Token struct maintains the position where the token was generated and the type of the token.
//! Using an enum for the types increases the readibility of the code.

#[derive(Debug)]
pub struct Token {
    pub kind: TokenKind,
    pub pos: usize,
}

impl Token {
    /// Constructs a new token with the given type and position.
    ///
    /// # Arguments
    /// `kind` - The type of this Token.
    /// `pos` - The position where this Token was created.
    pub fn new(kind: TokenKind, pos: usize) -> Token {
        Token { kind, pos }
    }
}

/// The TokenKind enum maintains all of the different Tokens that could occur within the program.
/// Using an enum allows for easy extensibility.

#[derive(Debug)]
pub enum TokenKind {
    Void,
    Any,
    IntegerLiteral(i64),
    FloatLiteral(f64),
    StringLiteral(String),
    Identifier(String),
    Push,
    Pop,
}

impl TokenKind {
    /// This function checks if the given name is an instrution. If it is, it returns the correct instruction token.
    /// This function is called by the lexer, specifically by the make_word function.
    ///
    /// # Arguments
    /// `name` - The name of the current word.
    pub fn is_instruction(name: &String) -> Option<TokenKind> {
        match name.to_ascii_lowercase().as_str() {
            "push" => Some(TokenKind::Push),
            "pop"  => Some(TokenKind::Pop),
            _ => None,
        }
    }
}
